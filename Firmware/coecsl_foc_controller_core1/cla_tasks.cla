//############################################################################
//
// FILE: lab_cla_tasks.cla
//
// TITLE: Lab - CLA
//
// C2K ACADEMY URL: https://dev.ti.com/tirex/explore/node?node=AOpze8ebskysmgA
// SY3VKSA__jEBbtmC__LATEST
//
// In this lab, we will use the Control Law Accelerator (CLA) to implement a
// FIR lowpass filter. We will apply a PWM waveform to the input of our
// lowpass filter, which will result in a sinusoidal waveform at the output.
// The PWM waveform will be generated using one of the ePWM modules and it
// will be sampled via the ADC at a given sample rate. Both the filtered and
// unfiltered waveforms will be viewed in a real-time Code Composer Studio
// (CCS) debug session via internal buffers. [[r! F28002x and F280013x Devices
// This lab cannot be performed on the F28002x and F280013x devices since they
// do not have a CLA. ]]
//
//############################################################################
// $Copyright:
// Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
//
// Redistribution and use in source and binary forms, with or without 
// modification, are permitted provided that the following conditions 
// are met:
// 
//   Redistributions of source code must retain the above copyright 
//   notice, this list of conditions and the following disclaimer.
// 
//   Redistributions in binary form must reproduce the above copyright
//   notice, this list of conditions and the following disclaimer in the 
//   documentation and/or other materials provided with the   
//   distribution.
// 
//   Neither the name of Texas Instruments Incorporated nor the names of
//   its contributors may be used to endorse or promote products derived
//   from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// $
//############################################################################

#include <shared.h>
#include "driverlib.h"
#include "device.h"
#include "board.h"
#include "F28x_Project.h"
#include "structs.h"
#include "user_config.h"
#include "hw_config.h"
#include "math_ops.h"

extern int cla_count;

extern uint16_t enc_pos;

extern EncoderStruct comm_encoder;

int motor_zero, encoder_cpr, encoder_zero;

__attribute__((interrupt)) void Cla1Task1(void)
{
    SpiaRegs.SPITXBUF = 0xFFFF;
   // Wait for SPIA to finish transmitting and receiving
   while(SpiaRegs.SPIFFRX.bit.RXFFST !=1) { }
   // Read the received data from SPIA
   enc_pos = SpiaRegs.SPIRXBUF & 0x3FFF;

   // take care of encoder multiturn and velocity calculations here ============================================

     /* updates EncoderStruct encoder with the latest sample
      * after elapsed time dt */
     EncoderStruct* encoder = &comm_encoder;
     float dt = 0.000025;

     /* Shift around previous samples */
     encoder->old_angle = encoder->angle_singleturn;
     int i;
     for(i = N_POS_SAMPLES-1; i>0; i--){encoder->angle_multiturn[i] = encoder->angle_multiturn[i-1];}

     /* SPI read/write */
     encoder->raw =  enc_pos;

//     /* Linearization */
//     int off_1 = encoder->offset_lut[(encoder->raw)>>9];             // lookup table lower entry
//     int off_2 = encoder->offset_lut[((encoder->raw>>9)+1)%128];     // lookup table higher entry
//     int off_interp = off_1 + ((off_2 - off_1)*(encoder->raw - ((encoder->raw>>9)<<9))>>9);     // Interpolate between lookup table entries
     encoder->count = encoder->raw; // + off_interp;


     /* Real angles in radians */
     encoder->angle_singleturn = ((float)(encoder->count-motor_zero))/((float)encoder_cpr);
     int int_angle = encoder->angle_singleturn;
     encoder->angle_singleturn = TWO_PI_F*(encoder->angle_singleturn - (float)int_angle);
     encoder->angle_singleturn = encoder->angle_singleturn<0 ? encoder->angle_singleturn + TWO_PI_F : encoder->angle_singleturn;

     encoder->elec_angle = (encoder->ppairs*(float)(encoder->count-encoder_zero))/((float)encoder_cpr);
     int_angle = (int)encoder->elec_angle;
     encoder->elec_angle = TWO_PI_F*(encoder->elec_angle - (float)int_angle);
     //encoder->elec_angle = TWO_PI_F*fmodf((encoder->ppairs*(float)(encoder->count-E_ZERO))/((float)ENC_CPR), 1.0f);
     encoder->elec_angle = encoder->elec_angle<0 ? encoder->elec_angle + TWO_PI_F : encoder->elec_angle; // Add 2*pi to negative numbers
     /* Rollover */
     int rollover = 0;
     float angle_diff = encoder->angle_singleturn - encoder->old_angle;
     if(angle_diff > PI_F){rollover = -1;}
     else if(angle_diff < -PI_F){rollover = 1;}
     encoder->turns += rollover;
     if(!encoder->first_sample){
         encoder->turns = 0;
         encoder->first_sample = 1;
     }

     /* Multi-turn position */
     encoder->angle_multiturn[0] = encoder->angle_singleturn + TWO_PI_F*(float)encoder->turns;

     encoder->velocity = (encoder->angle_multiturn[0] - encoder->angle_multiturn[N_POS_SAMPLES-1])/(dt*(float)(N_POS_SAMPLES-1));
     encoder->elec_velocity = encoder->ppairs*encoder->velocity;

   // end encoder multiturn and velocity calculations here =====================================================

    cla_count++;

}

__interrupt void Cla1Task2 ( void )
{

}

__interrupt void Cla1Task3 ( void )
{

}

__interrupt void Cla1Task4 ( void )
{

}

__interrupt void Cla1Task5 ( void )
{

}

__interrupt void Cla1Task6 ( void )
{

}

__interrupt void Cla1Task7 ( void )
{

}

__interrupt void Cla1Task8 ( void )
{

}
